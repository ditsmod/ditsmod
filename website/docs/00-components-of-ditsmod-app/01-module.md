---
sidebar_position: 1
---

# Модулі

Одним з головних елементів архітектури Ditsmod - є його модулі. Але чим хороша саме модульна архітектура? - Модульність дозволяє компонувати різні автономні елементи і складати з них масштабований застосунок. Саме завдяки автономності модулів, великі проекти простіше розробляти, тестувати, деплоїти та обслуговувати.

Така архітектура дозволяє ізолювати в одному модулі **декілька файлів коду**, що можуть мати різні ролі, але **спільну спеціалізацію**. Модуль можна порівняти з оркестром, в якому є різні інструменти, але усі вони створюють спільну музику. З іншого боку, потреба в ізоляції різних модулів виникає через те, що вони можуть мати різну спеціалізацію і через це - можуть заважати один-одному. Продовжуючи аналогію з людьми, якщо в одому кабінеті розмістити поліцію та музикантів, або брокерів і перекладачів, швидше за все, вони заважатимуть один-одному. Саме тому для модуля важлива **вузька спеціалізація**.

Модулі є найбільшими будівельними блоками застосунку, а в їхніх метаданих декларуються такі складові модуля як:
- контролери, що приймають HTTP-запити та відправляють HTTP-відповіді;
- сервіси, де описується бізнес логіка застосунку;
- інтерсептори та ґарди, що дозволяють автоматизувати обробку HTTP-запитів по типовим патернам;
- декоратори та розширення, що дозволяють доповнювати застосунок новими правилами та новою поведінкою;
- інші класи, інтерфейси, хелпери, типи даних, що призначаються для роботи поточного модуля.

Модулі є двох типів:

1. Root module (кореневий модуль).
2. Feature module (модуль фіч).

## Кореневий модуль {#root-module}

До кореневого модуля підв'язуються інші модулі, він є єдиним на увесь застосунок, а його клас рекомендовано називати `AppModule`. TypeScript клас стає кореневим модулем Ditsmod завдяки одному з таких декораторів як `rootModule`, `restRootModule`, `trpcRootModule` і т.д., в залежності від модуля, який ви використовуєте. Наприклад, якщо ви використовуєте REST, кореневий модуль оголошується наступним чином:

```ts
import { restRootModule } from '@ditsmod/rest';

@restRootModule()
export class AppModule {}
```

Загалом, в декоратор `restRootModule` можна передавати об'єкт з такими властивостями:

```ts
import { restRootModule } from '@ditsmod/rest';

@restRootModule({
  imports: [], // Імпорт модулів
  appends: [], // Прикріплення модулів, що мають контролери
  providersPerApp: [], // Провайдери на рівні застосунку
  providersPerMod: [], //         ...на рівні модуля
  providersPerRou: [], //         ...на рівні роуту
  providersPerReq: [], //         ...на рівні HTTP запиту
  exports: [], // Експорт модулів та провайдерів з поточного модуля
  extensions: [], // Розширення
  extensionsMeta: {}, // Дані для роботи розширень
  resolvedCollisionsPerApp: [], // Вирішення колізій імпортованих класів на рівні застосунку
  resolvedCollisionsPerMod: [], //                                    ...на рівні модуля
  resolvedCollisionsPerRou: [], //                                    ...на рівні роуту
  resolvedCollisionsPerReq: [], //                                    ...на рівні HTTP запиту
  controllers: [], // Список контролерів в поточному модулі
})
export class AppModule {}
```

## Модуль фіч {#feature-module}

TypeScript клас стає feature модулем Ditsmod завдяки одному з таких декораторів як `featureModule`, `restModule`, `trpcModule` і т.д., в залежності від модуля, який ви використовуєте. Наприклад, якщо ви використовуєте REST, кореневий модуль оголошується наступним чином:

```ts
import { restModule } from '@ditsmod/rest';

@restModule()
export class SomeModule {}
```

Файли модулів рекомендується називати із закінченням `*.module.ts`, а назви їхніх класів - із закінченням `*Module`.

Він може містити точно такі самі метадані як і кореневі модулі, за виключенням властивості `resolvedCollisionsPerApp`. Окрім того, що feature module можна декларувати прямо у застосунку, його також можна публікувати на npmjs.com.

[1]: https://www.npmjs.com/package/reflect-metadata
