---
sidebar_position: 1
---

# Модулі

Одним з головних елементів архітектури Ditsmod - є його модулі. Але чим хороша саме модульна архітектура? - Модульність дозволяє компонувати різні автономні елементи і складати з них масштабований застосунок. Саме завдяки автономності модулів, великі проекти простіше розробляти, тестувати, деплоїти та обслуговувати.

Така архітектура дозволяє ізолювати в одному модулі **декілька файлів коду**, що можуть мати різні ролі, але **спільну спеціалізацію**. Модуль можна порівняти з оркестром, в якому є різні інструменти, але усі вони створюють спільну музику. З іншого боку, потреба в ізоляції різних модулів виникає через те, що вони можуть мати різну спеціалізацію і через це - можуть заважати один-одному. Продовжуючи аналогію з людьми, якщо в одому кабінеті розмістити поліцію та музикантів, або брокерів і перекладачів, швидше за все, вони заважатимуть один-одному. Саме тому для модуля важлива **вузька спеціалізація**.

Разом з тим, модулі можуть мати ще й різні типи. Найчастіше використовуються два типи:

- **service** - сюди можна віднести модулі, що надають певні сервіси: модуль баз даних, модуль безпеки, модуль для запису логів, модуль для перекладу повідомлень різними мовами, і т.п.; такі модулі рідко закріпляються за певними URL.
- **routed** - сюди потрібно відносити модулі, що обслуговують певну частину URL: наприклад, один модуль може обробляти усі HTTP-запити за адресою `/api/users`, інший модуль - за адресою `/api/posts`.

Модулі є найбільшими будівельними блоками застосунку, а в їхніх метаданих декларуються такі складові модуля як:
- контролери, що приймають HTTP-запити та відправляють HTTP-відповіді;
- сервіси, де описується бізнес логіка застосунку;
- інтерсептори та ґарди, що дозволяють автоматизувати обробку HTTP-запитів по типовим патернам;
- декоратори та розширення, що дозволяють доповнювати застосунок новими правилами та новою поведінкою;
- інші класи, інтерфейси, хелпери, типи даних, що призначаються для роботи поточного модуля.

## Кореневий модуль {#root-module}

До кореневого модуля підв'язуються інші модулі, він є єдиним на увесь застосунок, а його клас рекомендовано називати `AppModule`. TypeScript клас стає кореневим модулем Ditsmod завдяки декоратору `rootModule`:

```ts
import { rootModule } from '@ditsmod/core';

@rootModule()
export class AppModule {}
```

Загалом, в декоратор `rootModule` можна передавати об'єкт з такими властивостями:

```ts
import { rootModule } from '@ditsmod/core';

@rootModule({
  imports: [], // Імпорт модулів
  providersPerApp: [], // Провайдери на рівні застосунку
  providersPerMod: [], //         ...на рівні модуля
  exports: [], // Експорт модулів та провайдерів з поточного модуля
  extensions: [], // Розширення
  extensionsMeta: {}, // Дані для роботи розширень
  resolvedCollisionsPerApp: [], // Вирішення колізій імпортованих класів на рівні застосунку
  resolvedCollisionsPerMod: [], //                                    ...на рівні модуля
  id: '', // Може використовуватись для динамічного додавання чи видалення модулів
})
export class AppModule {}
```

## Feature module {#feature-module}

TypeScript клас стає feature модулем Ditsmod завдяки декоратору `featureModule`:

```ts
import { featureModule } from '@ditsmod/core';

@featureModule()
export class SomeModule {}
```

Файли модулів рекомендується називати із закінченням `*.module.ts`, а назви їхніх класів - із закінченням `*Module`.

Він може містити точно такі самі метадані як і кореневі модулі, за виключенням властивості `resolvedCollisionsPerApp`. Окрім того, що `featureModule` можна декларувати прямо у застосунку, його також можна публікувати на npmjs.com.

[1]: https://www.npmjs.com/package/reflect-metadata
